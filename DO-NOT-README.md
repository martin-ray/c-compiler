#　The following is the note
読んだ事を書くことによって知識が定着する！！

#　コードー＞（コンパイラ）ー＞アセンブリー＞（アセンブラ）ー＞機械語ー＞（リンカ）ー＞実行ファイル、という流れ

## 実行ファイルの逆アセンブル方法
objdump -d -M -T intel 実行ファイル
で、なんでも逆アセンブルすることが可能。X64のアセンブリが見られます。

## ソースコードのアセンブル
gcc -S source.c


# アセンブリチートシート
## X64のレジスタについて
全部で16この64bitレジスタがるそうです。さらに、この64bitレジスタは32- 16- 8　ビットでのアクセスも可能だそう。
rax が、関数からの戻り値が入るレジスタと決まっている。

##　逆アセンブルされたx64の読み方
  3d58:  48 83 ec 08           sub    rsp,0x8
  メモリアドレス、機械語、それに対応するアセンブリ、って感じ。　MIPSとは結構違うんだよね。


#　メモリ領域に関して
## カーネル空間とユーザ空間

メモリの領域で、カーネル（os)が動いている領域をカーネル空間という。pcを起動すると一番最初にカーネルがカーネル空間に読み込まれる。
続いて、デーモンプロセスがユーザ空間に読み込まれる。
osとカーネルはほぼ同義で、3年生のときにやった大堀先生のソフトウェア工学で、osの仕事は3つあると習ったね。プロセス管理、メモリ管理、デバイス管理。
プロセスのアドレス空間の基本的な構造はそろそろ覚えておいていいかも。


#　OSに関して
ところで、linuxでは、限りある資源ですべてのプロセスを動かすためにコンテキストスイッチが発生するよね。
「コンテキストの保存領域としてthread_info構造体とカーネルスタックを併用します。 この二つはプロセス毎に割り当てられており、プロセス生成時に作成されます」
だそうです。
うん、プロセスがつぎのプロセスに切り替えられるまでに与えられるcpu時間のことをタイムスライスと言うんだね。それはそうだ。

「プロセスがどのような状態にあるか、どんな資源へアクセスしているかなどを管理する為、全てのプロセスに一つずつプロセスディスクリプタが割り当てられます。 Linuxでのプロセスディスクリプタはtask_struct構造体という名前になっていて、ここにプロセスに関する全ての情報が詰め込まれています。」
だそうです。実は、/proc/pid/にその情報が全部入ってたりします。。。


# 構文解析
コンパイルするためにはまず入力されたコードを解析しないとだめですね。それをパースっていうんですね。んで、構文解析の最も一般的なアルゴリズムの一つが「再帰下降構文解析法」で、これはgccにも使われている構文解析アルゴリズムらしいです。


#　リンカーについて
リンカーはオブジェクトファイルをつなぎ合わせて単体の実行ファイルやsoファイルを作る。実はldっていうコマンドがlinuxであるんだよね。マジである。はい。で、gccをやると中でldも間接的に呼び出されている。複数のファイルから実行ファイルを生成するときは、これからはMakefileを使うようにしよう、俺も。そっちの方がコンパイル、アセンブル、リンクの流れを忘れずに済むと思う。

# 再帰下降構文解析
トークンを更に抽象構文木にすることが目標です。

# バッカスなうあ記法
あーやっぱり、ここで正規表現について学ばないとだめなのかー。だるい。
正規表現とは、前に説明しましたように、「いくつかの文字列を一つの形式で表現するための表現方法」
が、まあ、やりますか。
出てくる文字列はたったの9個なので、あまりビビらずに行きましょうや。
まず、最初に知っておきたいのがLinuxにおけるワイルドカードと正規表現は違うってこと。
よく使うワイルドカードの*　これ、任意の０文字以上の文字列だけど、正規表現では違うからね？ちなみにワイルドカードの*の正規表現に相当するものは、.*　これな

(1) . なんでもいい１文字
(2) ^ $ 行の先頭と最後　　ex, ^ありがとう　ー＞マッチ例：ありがとうといいたい
(3)　* + ? 同じ文字の繰り返し。*は、直線の文字が0回以上続くとき。 + は直前の文字が１回以上続く時。　?はちょくぜんの文字が全く無いか、1回だけ続く時。
(4) .* なんでもいい文字の連続。Linuxのワイルドカードにおける*と同じ意味。
(5)　| いずれかの文字
(6) []指定した文字のどれか